# Golang面试题：GMP 中 work stealing 机制

## GMP 中 work stealing 机制

存到 P本地队列或者是全局队列。P此时去唤醒一个 M。P继续执行它的执行序。M寻找是否有空闲的 P，如果有则 将该 G对象移动到它本身。接下来 M执行一个调度循环(调用 G对象->执行->清理线程→继续找新的 Goroutine 执 行)。

## GMP 中 hand off 机制

当本线程 M因为 G进行的系统调用阻塞时，线程释放绑定的 P，把 P转移给其他空闲的 M'执行。当发生上线文切换 时，需要对执行现场进行保护，以便下次被调度执行时进行现场恢复。Go调度器 M的栈保存在 G对象上，只需要 将 M所需要的寄存器(SP、PC等)保存到 G对象上就可以实现现场保护。当这些寄存器数据被保护起来，就随时可以 做上下文切换了，在中断之前把现场保存起来。如果此时 G任务还没有执行完，M可以将任务重新丢到 P的任务队 列，等待下一次被调度执行。当再次被调度执行时，M通过访问 G的 vdsoSP、vdsoPC寄存器进行现场恢复(从上次 中断位置继续执行)。

## GMP 调度过程中存在哪些阻塞

- I/O，select
- block on syscall channel
- 等待锁 runtime.Gosched()