# Golang面试题：GC

## GC 触发时机

主动触发:调用 runtime.GC 

被动触发:

使用系统监控，该触发条件由 runtime.forcegcperiod 变量控制，默认为2 分钟。当超过两分钟没有产生任何 GC 时，强制触发 GC。

使用步调(Pacing)算法，其核心思想是控制内存增⻓的比例。如 Go 的 GC 是一种比例 GC,下一次 GC 结束时的 堆大小和上一次 GC 存活堆大小成比例.由 GOGC 控制,默认100,即2 倍的关系,200 就是3 倍,
当 Go新创建的对象所占用的内存大小，除以上次 GC结束后保留下来的对象占用内存大小。


## Go 语言中 GC 的流程是什么?

当前版本的 Go 以 STW 为界限，可以将 GC 划分为五个阶段:阶段说明赋值器状态 GCMark标记准备阶段，为并发 标记做准备工作，启动写屏障 STWGCMark扫描标记阶段，与赋值器并发执行，写屏障开启并发 GCMarkTermination 标记终止阶段，保证一个周期内标记任务完成，停止写屏障 STWGCoff内存清扫阶段，将需 要回收的内存归还到堆中，写屏障关闭并发 GCoff内存归还阶段，将过多的内存归还给操作系统，写屏障关闭并 发。

## GC 如何调优

通过 go tool pprof 和 go tool trace 等工具

控制内存分配的速度，限制 goroutine 的数量，从而提高赋值器对 CPU 的利用率。 减少并复用内存，例如使用 sync.Pool 来复用需要频繁创建临时对象，例如提前分配足够的内存来降低多余的 拷⻉。

需要时，增大 GOGC 的值，降低 GC 的运行频率
